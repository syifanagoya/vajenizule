<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="I would like to add a retry mechanism to Python Requests library, so scripts that are using it will retry for non-fatal errors. At this moment I do consider three kind of errors to be recoverable: At the first stage I do want to retry specified 5xx requests every minute."><meta name=author content="Reinaldo Massengill"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=PulseDash><title>How to implement retry mechanism into Python Requests library? - PulseDash</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[PulseDash]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-03-06>March 06, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>How to implement retry mechanism into Python Requests library?</h1><section class=body itemprop=articleBody><img src=https://cdn.statically.io/img/cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>I would like to add a retry mechanism to Python <a href=# rel=noreferrer>Requests</a> library, so scripts that are using it will retry for non-fatal errors.</p><p>At this moment I do consider three kind of errors to be recoverable:</p><ul><li>HTTP return codes 502, 503, 504</li><li>host not found (less important now)</li><li>request timeout</li></ul><p>At the first stage I do want to retry specified 5xx requests every minute.</p><p>I want to be able to add this functionality transparently, without having to manually implement recovery for each HTTP call made from inside these scripts or libraries that are using Python Requests.</p><span class=d-none itemprop=commentCount>5</span><h2 class=mb0 data-answercount=6>6 Answers</h2><p>This snippet of code will make all HTTP requests from the same session retry for a total of 5 times, sleeping between retries with an increasing backoff of 0s, 2s, 4s, 8s, 16s (the first retry is done immediately). It will retry on basic connectivity issues (including DNS lookup failures), and HTTP status codes of 502, 503 and 504.</p><pre><code>import logging import requests from requests.adapters import HTTPAdapter, Retry logging.basicConfig(level=logging.DEBUG) s = requests.Session() retries = Retry(total=5, backoff_factor=1, status_forcelist=[ 502, 503, 504 ]) s.mount('http://', HTTPAdapter(max_retries=retries)) s.get("http://httpstat.us/503") </code></pre><p>See <a href=# rel=noreferrer>Retry class</a> for details.</p><span class=d-none itemprop=commentCount>11</span><p>This is a snippet of code I used to retry for the petitions made with urllib2. Maybe you could use it for your purposes:</p><pre><code>retries = 1 success = False while not success: try: response = urllib2.urlopen(request) success = True except Exception as e: wait = retries * 30; print 'Error! Waiting %s secs and re-trying...' % wait sys.stdout.flush() time.sleep(wait) retries += 1 </code></pre><p>The waiting time grows incrementally to avoid be banned from server.</p><span class=d-none itemprop=commentCount>2</span><p>Possible solution using <a href=# rel=noreferrer>retrying package</a></p><pre><code>from retrying import retry import requests def retry_if_connection_error(exception): """ Specify an exception you need. or just True""" #return True return isinstance(exception, ConnectionError) # if exception retry with 2 second wait @retry(retry_on_exception=retry_if_connection_error, wait_fixed=2000) def safe_request(url, **kwargs): return requests.get(url, **kwargs) response = safe_request('test.com') </code></pre><span class=d-none itemprop=commentCount>3</span><pre><code>from requests.adapters import HTTPAdapter from urllib3.util.retry import Retry MAX_RETRY = 2 MAX_RETRY_FOR_SESSION = 2 BACK_OFF_FACTOR = 0.3 TIME_BETWEEN_RETRIES = 1000 ERROR_CODES = (500, 502, 504) def requests_retry_session(retries=MAX_RETRY_FOR_SESSION, back_off_factor=BACK_OFF_FACTOR, status_force_list=ERROR_CODES, session=None): session = session retry = Retry(total=retries, read=retries, connect=retries, backoff_factor=back_off_factor, status_forcelist=status_force_list, method_whitelist=frozenset(['GET', 'POST'])) adapter = HTTPAdapter(max_retries=retry) session.mount('http://', adapter) session.mount('https://', adapter) return session class ConfigService: def __init__(self): self.session = requests_retry_session(session=requests.Session()) def call_to_api(): config_url = 'http://localhost:8080/predict/' headers = { "Content-Type": "application/json", "x-api-key": self.x_api_key } response = self.session.get(config_url, headers=headers) return response </code></pre><span class=d-none itemprop=commentCount>1</span><p>I was able to obtain the desired level of reliability by extending <code>requests.Session</code> class.</p><p>Here is the code <a href=# rel="nofollow noreferrer">https://bitbucket.org/bspeakmon/jira-python/src/a7fca855394402f58507ca4056de87ccdbd6a213/jira/resilientsession.py?at=master</a></p><p><strong>EDIT</strong> That code was:</p><pre><code>from requests import Session from requests.exceptions import ConnectionError import logging import time class ResilientSession(Session): """ This class is supposed to retry requests that do return temporary errors. At this moment it supports: 502, 503, 504 """ def __recoverable(self, error, url, request, counter=1): if hasattr(error,'status_code'): if error.status_code in [502, 503, 504]: error = "HTTP %s" % error.status_code else: return False DELAY = 10 * counter logging.warn("Got recoverable error [%s] from %s %s, retry #%s in %ss" % (error, request, url, counter, DELAY)) time.sleep(DELAY) return True def get(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).get(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'GET', counter): continue return r def post(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).post(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'POST', counter): continue return r def delete(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).delete(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'DELETE', counter): continue return r def put(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).put(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'PUT', counter): continue return r def head(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).head(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'HEAD', counter): continue return r def patch(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).patch(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'PATCH', counter): continue return r def options(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).options(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'OPTIONS', counter): continue return r </code></pre><span class=d-none itemprop=commentCount>4</span><p><strong>Method to retry certain logic if some exception has occured at time intervals t1=1 sec, t2=2 sec, t3=4 sec.</strong> We can increase/decrease the time interval as well.</p><pre><code>MAX_RETRY = 3 retries = 0 try: call_to_api() // some business logic goes here. except Exception as exception: retries += 1 if retries &lt;= MAX_RETRY: print("ERROR=Method failed. Retrying ... #%s", retries) time.sleep((1 &lt;&lt; retries) * 1) // retry happens after time as a exponent of 2 continue else: raise Exception(exception) </code></pre><span class=d-none itemprop=commentCount></span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoaWxqZmyBcYWOoaawZaSkeqq5z6Wcpp2eqXqzsdOrsGallZi1orrIrKRmoZ6pvG682K2fqKZdp7KywcSsq6xlnJ6vs63Rsg%3D%3D</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 PulseDash - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>